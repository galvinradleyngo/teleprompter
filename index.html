<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Teleprompter — Operator & Prompter (Top Toolbar)</title>
<style>
  :root{
    --fontSize: 64px;      /* px */
    --padLRvw: 8;          /* vw */
    --padTBvh: 0;          /* vh — top/bottom kept 0 as requested */
    --guideY: 35%;         /* % from top */
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}

  /* Layout: Top toolbar + full-width preview below */
  body{display:flex;flex-direction:column;min-height:100vh}
  .topbar{position:sticky;top:0;z-index:10;background:#0e0e0e;border-bottom:1px solid #222}
  .topbar-inner{max-width:1400px;margin:0 auto;padding:12px 16px;display:grid;grid-template-columns:1fr auto;gap:12px}
  .controls{display:grid;grid-template-columns:repeat(4, minmax(220px, 1fr));gap:10px 16px;align-items:center}
  .controls label{display:flex;align-items:center;justify-content:space-between;gap:12px;font-size:14px;background:#0b0b0b;border:1px solid #222;border-radius:12px;padding:8px 10px}
  .controls input[type="range"]{width:180px}
  .muted{opacity:.75;font-size:12px}

  .actions{display:flex;flex-direction:column;gap:8px;align-items:flex-end}
  .actions .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end}

  .toggles{display:flex;gap:16px;align-items:center;flex-wrap:wrap}
  .toggle{display:flex;gap:10px;align-items:center;background:#0b0b0b;border:1px solid #222;border-radius:999px;padding:8px 12px;font-size:14px}
  .toggle input{margin:0}

  button{background:#1f1f1f;color:#fff;border:1px solid #333;border-radius:12px;padding:10px 14px;cursor:pointer}
  button:hover{background:#262626}

  .script-wrap{max-width:1400px;margin:0 auto;padding:0 16px 10px}
  .script-wrap label{display:block;margin:6px 0 6px;font-size:12px;opacity:.9}
  textarea{height:120px;width:100%;resize:vertical;background:#0a0a0a;color:#fff;border:1px solid #222;border-radius:10px;padding:10px}

  .viewer{position:relative;overflow:auto;flex:1;border-top:1px solid #222}
  .content{font-size:var(--fontSize);line-height:1.2; padding:calc(var(--padTBvh)*1vh) calc(var(--padLRvw)*1vw); white-space:pre-wrap;word-break:break-word}
  .guide{position:absolute;left:0;right:0;height:2px;background:#f44336;top:var(--guideY);opacity:.8;pointer-events:none}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;background:#111;border:1px solid #333;border-radius:6px;padding:2px 6px}

  /* Prompter-only transforms */
  .mirrorX{transform:scaleX(-1)}
  .flipY{transform:scaleY(-1)}

  /* Make arrow keys scroll only the viewer */
  .viewer:focus{outline:2px solid #2a7fff}
</style>
</head>
<body>
  <!-- Sticky Top Toolbar -->
  <div class="topbar">
    <div class="topbar-inner">
      <div>
        <h2 style="margin:0 0 6px">Operator</h2>
        <div class="muted">Preview below exactly matches Prompter — operator is always unflipped for readability.</div>
      </div>
      <div class="actions">
        <div class="row">
          <button id="openPrompter">Open Prompter Window</button>
          <span class="muted">Keys: <span class="kbd">Space</span> autoscroll, <span class="kbd">↑/↓</span> nudge, <span class="kbd">G</span> guide</span>
        </div>
        <div class="toggles">
          <label class="toggle"><input id="showGuide" type="checkbox" checked> Show Guide</label>
          <label class="toggle"><input id="autoscroll" type="checkbox"> Autoscroll</label>
          <label class="toggle"><input id="invertH" type="checkbox"> Mirror (Prompter only)</label>
          <label class="toggle"><input id="invertV" type="checkbox"> Flip (Prompter only)</label>
        </div>
      </div>
    </div>

    <div class="topbar-inner" style="grid-template-columns:1fr;gap:10px 16px;">
      <div class="controls" id="controls">
        <label>Font Size <span style="display:flex;gap:10px;align-items:center"><input id="fontSize" type="range" min="20" max="160" value="64"><span id="fontSizeVal">64px</span></span></label>
        <label>Side Margin <span style="display:flex;gap:10px;align-items:center"><input id="padLR" type="range" min="0" max="20" step="1" value="8"><span id="padLRVal">8vw</span></span></label>
        <label>Guide Position <span style="display:flex;gap:10px;align-items:center"><input id="guidePos" type="range" min="5" max="90" value="35"><span id="guideVal">35%</span></span></label>
        <label>Speed <span style="display:flex;gap:10px;align-items:center"><input id="speed" type="range" min="10" max="300" step="5" value="80"><span id="speedVal">80 px/s</span></span></label>
      </div>
    </div>

    <div class="script-wrap">
      <label>Script</label>
      <textarea id="script" placeholder="Type or paste your script here..."></textarea>
      <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;margin-top:6px">
        <button id="applyScript">Load to Preview & Prompter</button>
        <span id="status" class="muted">–</span>
      </div>
    </div>
  </div>

  <!-- Full-width Operator Preview -->
  <div class="viewer" id="viewer" tabindex="0" aria-label="Operator preview (scroll area)">
    <div class="guide" id="guide"></div>
    <div class="content" id="content"></div>
  </div>

<script>
(function(){
  // --- State ---
  const state = {
    text: '',
    fontSize: 64,
    padLR: 8,
    padTB: 0,
    guidePos: 35,
    guideVisible: true,
    speed: 80,         // px/s
    autoscroll: false,
    invertH: false,
    invertV: false,
    scrollTop: 0
  };

  // --- DOM ---
  const viewer = document.getElementById('viewer');
  const content = document.getElementById('content');
  const guide = document.getElementById('guide');
  const scriptBox = document.getElementById('script');
  const status = document.getElementById('status');

  const fontSize = document.getElementById('fontSize');
  const fontSizeVal = document.getElementById('fontSizeVal');
  const padLR = document.getElementById('padLR');
  const padLRVal = document.getElementById('padLRVal');
  const guidePos = document.getElementById('guidePos');
  const guideVal = document.getElementById('guideVal');
  const speed = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const showGuide = document.getElementById('showGuide');
  const autoscroll = document.getElementById('autoscroll');
  const invertH = document.getElementById('invertH');
  const invertV = document.getElementById('invertV');
  const openBtn = document.getElementById('openPrompter');
  const applyBtn = document.getElementById('applyScript');

  let prompterWin = null;
  let pingTimer = null;
  let autosTimer = null;  // operator-side autoscroll
  let isRemoteScroll = false; // prevents feedback loops

  // --- Operator-side autoscroll (runs only when prompter is NOT open) ---
  function stopOpAuto(){ if(autosTimer){ cancelAnimationFrame(autosTimer); autosTimer=null; } }
  function stepOp(){
    const sp = state.speed || 0;
    let last = performance.now();
    function tick(t){
      const dt = (t - last) / 1000; last = t;
      viewer.scrollTop += sp * dt;
      state.scrollTop = viewer.scrollTop;
      // broadcast to prompter so it follows when open
      send({type:'scroll', scrollTop: state.scrollTop});
      autosTimer = requestAnimationFrame(tick);
    }
    autosTimer = requestAnimationFrame(tick);
  }
  function manageAuto(){
    stopOpAuto();
    if(state.autoscroll){
      // If no prompter, operator drives autoscroll; if prompter exists, child drives
      if(!prompterWin || prompterWin.closed){ stepOp(); }
    }
  }

  // --- Rendering: Operator preview must match Prompter except flipping ---
  function render(){
    content.textContent = state.text || '';
    document.documentElement.style.setProperty('--fontSize', state.fontSize + 'px');
    document.documentElement.style.setProperty('--padLRvw', state.padLR);
    document.documentElement.style.setProperty('--padTBvh', state.padTB);
    document.documentElement.style.setProperty('--guideY', state.guidePos + '%');
    guide.style.display = state.guideVisible ? 'block' : 'none';

    // Ensure operator view is never flipped
    content.classList.remove('mirrorX','flipY');

    // Scroll position from state
    isRemoteScroll = true;
    viewer.scrollTop = state.scrollTop || 0;
    isRemoteScroll = false;

    // UI bindings
    fontSize.value = state.fontSize; fontSizeVal.textContent = state.fontSize + 'px';
    padLR.value = state.padLR; padLRVal.textContent = state.padLR + 'vw';
    guidePos.value = state.guidePos; guideVal.textContent = state.guidePos + '%';
    speed.value = state.speed; speedVal.textContent = state.speed + ' px/s';
    showGuide.checked = state.guideVisible;
    autoscroll.checked = state.autoscroll;
    invertH.checked = state.invertH; invertV.checked = state.invertV;
  }

  function send(msg){
    if (prompterWin && !prompterWin.closed){
      prompterWin.postMessage(msg, '*');
    }
  }

  function broadcastState(){ send({type:'state', state}); }

  // --- Prompter child window template ---
  function prompterHTML(){
    return `<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Prompter</title>
<style>
  :root{--fontSize:${state.fontSize}px;--padLRvw:${state.padLR};--padTBvh:${state.padTB};--guideY:${state.guidePos}%}
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .viewer{position:relative;height:100%;overflow:auto}
  .content{font-size:var(--fontSize);line-height:1.2;padding:calc(var(--padTBvh)*1vh) calc(var(--padLRvw)*1vw);white-space:pre-wrap;word-break:break-word;}
  .guide{position:sticky;top:var(--guideY);height:2px;background:#f44336;opacity:.8}
  .mirrorX{transform:scaleX(-1)}
  .flipY{transform:scaleY(-1)}
</style>
</head>
<body>
  <div class="viewer" id="v">
    <div class="guide" id="g"></div>
    <div class="content" id="c"></div>
  </div>
<script>
(function(){
  const viewer = document.getElementById('v');
  const content = document.getElementById('c');
  const guide = document.getElementById('g');
  let state = {text:'',fontSize:64,padLR:8,padTB:0,guidePos:35,guideVisible:true,speed:80,autoscroll:false,invertH:false,invertV:false,scrollTop:0};
  let autosTimer=null; let isRemoteScroll=false;

  function apply(){
    content.textContent = state.text || '';
    document.documentElement.style.setProperty('--fontSize', state.fontSize + 'px');
    document.documentElement.style.setProperty('--padLRvw', state.padLR);
    document.documentElement.style.setProperty('--padTBvh', state.padTB);
    document.documentElement.style.setProperty('--guideY', state.guidePos + '%');
    guide.style.display = state.guideVisible ? 'block' : 'none';

    content.classList.toggle('mirrorX', !!state.invertH);
    content.classList.toggle('flipY', !!state.invertV);

    isRemoteScroll = true;
    viewer.scrollTop = state.scrollTop || 0;
    isRemoteScroll = false;

    if(autosTimer){cancelAnimationFrame(autosTimer); autosTimer=null;}
    if(state.autoscroll){ step(); }
  }

  function step(){
    const sp = state.speed || 0;
    let last = performance.now();
    function tick(t){
      const dt = (t-last)/1000; last=t;
      viewer.scrollTop += sp*dt;
      // tell parent so operator preview stays in sync
      window.parent && window.parent.postMessage({type:'scroll', scrollTop: viewer.scrollTop}, '*');
      autosTimer = requestAnimationFrame(tick);
    }
    autosTimer = requestAnimationFrame(tick);
  }

  window.addEventListener('message', (e)=>{
    const d=e.data||{};
    if(d.type==='ping'){
      window.parent && window.parent.postMessage({type:'pong'}, '*');
    }else if(d.type==='state'){
      state = d.state||state; apply();
    }else if(d.type==='scroll'){
      isRemoteScroll = true; viewer.scrollTop = d.scrollTop||0; isRemoteScroll=false;
    }
  });

  viewer.addEventListener('scroll',()=>{
    if(isRemoteScroll) return;
    state.scrollTop = viewer.scrollTop;
    window.parent && window.parent.postMessage({type:'scroll', scrollTop:state.scrollTop}, '*');
  }, {passive:true});

  // initial ready signal
  window.parent && window.parent.postMessage({type:'ready'}, '*');
})();
<\/script>
</body></html>`;
  }

  // --- Open prompter window ---
  function openPrompter(){
    status.textContent = 'Opening prompter…';
    if (prompterWin && !prompterWin.closed){ try{prompterWin.close();}catch{}}
    prompterWin = window.open('', 'TeleprompterWindow', 'popup=yes,width=1200,height=800');
    if(!prompterWin){ alert('Pop‑up blocked. Please allow pop‑ups for this site.'); status.textContent='Popup blocked.'; return; }

    // write a full, closed document to avoid partial-write errors
    prompterWin.document.open();
    prompterWin.document.write(prompterHTML());
    prompterWin.document.close();

    // handshake
    if (pingTimer) clearInterval(pingTimer);
    pingTimer = setInterval(()=>{
      try{ if (prompterWin && !prompterWin.closed) prompterWin.postMessage({type:'ping'}, '*'); }catch{}
    }, 500);

    // send current state after a brief delay to ensure script is ready
    setTimeout(()=>{ broadcastState(); status.textContent='Prompter ready.'; manageAuto(); }, 300);
  }

  // --- Event wiring ---
  openBtn.addEventListener('click', openPrompter);

  applyBtn.addEventListener('click', ()=>{
    state.text = scriptBox.value;
    render();
    broadcastState();
  });

  fontSize.addEventListener('input', ()=>{ state.fontSize = +fontSize.value; render(); broadcastState(); });
  padLR.addEventListener('input',   ()=>{ state.padLR   = +padLR.value;   render(); broadcastState(); });
  guidePos.addEventListener('input',()=>{ state.guidePos= +guidePos.value; render(); broadcastState(); });
  speed.addEventListener('input',   ()=>{ state.speed   = +speed.value;   render(); broadcastState(); manageAuto(); });
  showGuide.addEventListener('change',()=>{ state.guideVisible = showGuide.checked; render(); broadcastState(); });
  autoscroll.addEventListener('change',()=>{ state.autoscroll = autoscroll.checked; render(); broadcastState(); manageAuto(); });
  invertH.addEventListener('change',()=>{ state.invertH = invertH.checked; render(); broadcastState(); });
  invertV.addEventListener('change',()=>{ state.invertV = invertV.checked; render(); broadcastState(); });

  // --- Scroll sync: operator -> prompter ---
  viewer.addEventListener('scroll', ()=>{
    if(isRemoteScroll) return;
    state.scrollTop = viewer.scrollTop;
    send({type:'scroll', scrollTop: state.scrollTop});
  }, {passive:true});

  // --- Keyboard control focused to viewer only ---
  function scrollBy(amount){
    viewer.scrollTop = Math.max(0, viewer.scrollTop + amount);
  }
  document.addEventListener('keydown', (e)=>{
    // ensure keys control only the preview scroller
    if (['ArrowUp','ArrowDown',' ','Spacebar','g','G'].includes(e.key)) e.preventDefault();
    if (e.key==='ArrowUp') scrollBy(-60);
    else if (e.key==='Down' || e.key==='ArrowDown') scrollBy(60);
    else if (e.key===' ' || e.key==='Spacebar'){
      autoscroll.checked = !autoscroll.checked; state.autoscroll = autoscroll.checked; render(); broadcastState(); manageAuto();
    }
    else if (e.key==='g' || e.key==='G'){ showGuide.checked = !showGuide.checked; state.guideVisible = showGuide.checked; render(); broadcastState(); }
  });

  // --- Receive from prompter ---
  window.addEventListener('message', (e)=>{
    const d=e.data||{};
    if(d.type==='pong'){
      if (pingTimer) { clearInterval(pingTimer); pingTimer=null; }
      status.textContent = 'Connected to prompter';
      manageAuto(); // ensure operator stops driving when child is present
    } else if (d.type==='scroll'){
      // Mirror child scroll to operator without loop
      isRemoteScroll = true; viewer.scrollTop = d.scrollTop||0; isRemoteScroll=false;
      state.scrollTop = viewer.scrollTop;
    } else if (d.type==='ready'){
      // Child reported ready — push full state
      broadcastState();
      manageAuto();
    }
  });

  // Initial demo text for quick testing
  state.text = `THIS IS A SAMPLE TELEPROMPTER SCRIPT

Use the controls to adjust font size, margins, speed, and guide.
Open the prompter window and drag it to your second display.

Press Space to toggle autoscroll. Use ↑/↓ to nudge.`;
  render();
  manageAuto();
})();
</script>
</body>
</html>
